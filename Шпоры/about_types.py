num = 2.0
num2 = 4.5
# Тип данных - число целое (int) и число десятичное (float)
'''
+ - складывает числа num + num2 => 6.5
- - вычитает из одного числа другое num - num2 = -2.5
* - умножает одно число на другое  num * num2 = 9.0 (int * float = float)
/ - делит одно число на другое num2 / num = 2.25 
** - возводит в степень - num ** num = 4
// - целая часть от деления 10 // 3 = 3
% - остаток после целой части от деления 10 % 3 = 1



num.as_integer_ratio() - метод, который дает числитель и знаменатель дроби
Допустим, есть число 0.25. Это 25/100, если представить в виде дроби. Сокращается до 1/4.
Метод выдаст кортеж (1, 4)
На целые числа, например, 3, он выдаст (3, 1), ибо 3 - это 3/1 в виде дроби

num.bit_length() - количество бит, сколько нужно для представления числа. Чтобы представить число в виде бит - bin(num)

num.conjugate() - возвращает сопряженное число. Подробнее: https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BF%D1%80%D1%8F%D0%B6%D1%91%D0%BD%D0%BD%D1%8B%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%B0

num.is_integer() - проверяет, является ли float-число целым
'''


first_part = "первая"
second_part = 'вторая'

"""
Тип данных - строка (str)

first_part + ",  " + second - склеивание строк (Конкатенация)
f"{first_part}, {second_part} - ф-строка, у которой одна цель - чтобы вставить в строку переменные. Любого типа

верхний регистр - ЭТО БОЛЬШИЕ БУКВЫ
малый регистр - это маленькие буквы
индекс - это порядковый номер, координата букв и символов в строке. например, "первая" - "п" - это 0, "е" - это 1, "р" - это 2 и т.д.


first_part.capitalize() - переводит первую букву строки в верхний регистр 

first_part.casefold() - вся строка в нижнем регистре

first_part.center(width, fillchar) - центрирует текст, добавляя пробелы слева и справа. Сколько? это параметр width. Не хотите пробелы? это параметр fillchar. 
    width = 5, fillchar="*" даст *****первая*****
    
first_part.count(sub, start, end) - считает, сколько раз упоминается подстрока sub. Можно ограничить конкретное место, указав индексы start и end
    "бебебе".count("e") - выдаст 3
    "бебебе".count("е", start=2) - выдаст 2
    
first_part.endswith(sub, start, end) - возвращает True, если строка заканчивается на sub. Можно уточнять, что именно является концом строки с start и end

first_part.startswith(sub, start, end)- возвращает True, если строка начинается на sub. Можно уточнять, что именно является началом строки с start и end

first_part.find(sub, start, end) - возвращает индекс первого попавшего sub в строке. Например, "бебебе".find("е") даст 1 - индекс первой е

first_part.isalnum() - возвращает True, если все символы в строке являются буквами или цифрами

first_part.isalpha() - возвращает True, если все символы в строке являются буквами

first_part.isascii() - возвращает True, если все символы в строке являются ASCII символами

first_part.isdecimal() - возвращает True, если все символы в строке являются десятичными цифрами

first_part.isdigit() - возвращает True, если все символы в строке являются цифрами

first_part.isidentifier() - возвращает True, если строка является допустимым идентификатором Python

first_part.islower() - возвращает True, если все символы в строке в нижнем регистре

first_part.isnumeric() - возвращает True, если все символы в строке являются числовыми

first_part.isprintable() - возвращает True, если все символы в строке являются печатаемыми

first_part.isspace() - возвращает True, если все символы в строке являются пробельными символами

first_part.istitle() - возвращает True, если строка является заголовком (каждое слово начинается с заглавной буквы)

first_part.isupper() - возвращает True, если все символы в строке в верхнем регистре

first_part.join(iterable) - объединяет элементы итерируемого объекта в строку, используя first_part как разделитель
    " ".join(["бе", "бе", "бе"]) - будет "бе бе бе"
    "-*-".join(["бе", "бе", "бе"]) - будет "бе-*-бе-*-бе" 

first_part.ljust(width, fillchar) - выравнивает строку по левому краю, добавляя пробелы справа. Ширина задается параметром width, fillchar опционально задает символ заполнителя

first_part.lower() - преобразует все символы строки в нижний регистр

first_part.lstrip(chars) - удаляет пробельные символы или указанные символы chars слева от строки

first_part.partition(sep) - разделяет строку на кортеж из трех элементов: часть перед первым вхождением разделителя sep, сам разделитель sep и часть после разделителя

first_part.replace(old, new, count) - заменяет все вхождения строки old на строку new. Параметр count указывает максимальное количество замен

first_part.rfind(sub, start, end) - возвращает индекс последнего вхождения sub в строке

first_part.rindex(sub, start, end) - возвращает индекс последнего вхождения sub в строке, вызывает ValueError, если sub не найден

first_part.rjust(width, fillchar) - выравнивает строку по правому краю, добавляя пробелы слева. Ширина задается параметром width, fillchar опционально задает символ заполнителя

first_part.rpartition(sep) - разделяет строку на кортеж из трех элементов: часть перед последним вхождением разделителя sep, сам разделитель sep и часть после разделителя

first_part.rsplit(sep, maxsplit) - разделяет строку справа налево по разделителю sep, maxsplit опционально задает максимальное количество разбиений

first_part.rstrip(chars) - удаляет пробельные символы или указанные символы chars справа от строки

first_part.split(sep, maxsplit) - разделяет строку слева направо по разделителю sep, maxsplit опционально задает максимальное количество разбиений

first_part.splitlines(keepends) - разделяет строку на линии. Если keepends=True, возвращаемые строки будут содержать символы конца строки

first_part.startswith(prefix, start, end) - возвращает True, если строка начинается с указанного префикса prefix, можно ограничить начало и конец строки с start и end

first_part.strip(chars) - удаляет пробельные символы или указанные символы chars с обоих концов строки

first_part.swapcase() - меняет регистр каждой буквы строки: верхний на нижний и наоборот

first_part.title() - возвращает строку, в которой первая буква каждого слова в верхнем регистре, а все остальные в нижнем

first_part.upper() - преобразует все символы строки в верхний регистр

first_part.zfill(width) - дополняет строку нулями слева до указанной ширины width

 
"""


is_correct = True

'''
Тип данных - логический (bool)

Это "да/нет" в мире программирования
"есть/нет"
"вкл/выкл"
https://disk.yandex.ru/i/zpWARyftvCI-hA

'''


fruits = ['яблоко', 'банан', 'вишня']

'''
Тип данных - список (list)

Состоит из элементов. У каждого элемента есть порядковый номер - индекс.
Да, как у строки. Но в отличие от строки, позволяет изменить элемент или удалить.

Может состоять из любых типов данных: из чисел, строк, булевых значений, словарей, других списков...


fruits.append(x) - добавляет элемент x в конец списка
    fruits.append('груша') # результат: ['яблоко', 'банан', 'вишня', 'груша']

fruits.clear() - удаляет все элементы из списка
    fruits.clear() # результат: []

fruits.copy() - возвращает поверхностную копию списка
    fruits_copy = fruits.copy() # результат: ['яблоко', 'банан', 'вишня']

fruits.count(x) - возвращает количество вхождений элемента x в список
    fruits.count('яблоко') # результат: 1

fruits.extend(iterable) - расширяет список, добавляя в конец все элементы из итерируемого объекта
    fruits.extend(['апельсин', 'киви']) # результат: ['яблоко', 'банан', 'вишня', 'апельсин', 'киви']

fruits.index(x, start, end) - возвращает индекс первого вхождения элемента x в список, можно указать диапазон поиска с помощью start и end
    fruits.index('банан') # результат: 1

fruits.insert(i, x) - вставляет элемент x на позицию с индексом i
    fruits.insert(1, 'апельсин') # результат: ['яблоко', 'апельсин', 'банан', 'вишня']

fruits.pop(i) - удаляет и возвращает элемент с индексом i (по умолчанию последний элемент)
    fruits.pop() # результат: 'вишня', список: ['яблоко', 'банан']

fruits.remove(x) - удаляет первое вхождение элемента x в список
    fruits.remove('банан') # результат: ['яблоко', 'вишня']

fruits.reverse() - разворачивает список на месте
    fruits.reverse() # результат: ['вишня', 'банан', 'яблоко']

fruits.sort(key=None, reverse=False) - сортирует элементы списка на месте. Можно указать ключ сортировки key и параметр reverse для обратного порядка
    fruits.sort() # результат: ['банан', 'вишня', 'яблоко']
    fruits.sort(reverse=True) # результат: ['яблоко', 'вишня', 'банан']

'''


amount_nums = list(range(20, 10, -1))

'''
Тип данных - диапазон (range)

Принимает 1, 2 ИЛИ 3 аргумента:
1 - это будет конец диапазона. range(4) - это 4 числа: 0, 1, 2, 3
2 - одно число начало, а второе - конец диапазона. range(1, 4) - это числа 1, 2, 3
3 - это начало, конец и шаг диапазона. range(1, 4, 2) - это числа 1, 3
'''



fruits = ('яблоко', 'банан', 'вишня')

"""
Тип данных - кортеж (tuple)

Кортежи, в отличие от списков, являются неизменяемыми (immutable), поэтому они не поддерживают методы, изменяющие их содержимое, такие как append, remove, clear и т. д. 



fruits.count(x) - возвращает количество вхождений элемента x в кортеж
    fruits.count('яблоко') # результат: 1

fruits.index(x, start, end) - возвращает индекс первого вхождения элемента x в кортеже, можно указать диапазон поиска с помощью start и end
    fruits.index('банан') # результат: 1

# Основные функции, которые можно использовать с кортежами

len(fruits) - возвращает количество элементов в кортеже
    len(fruits) # результат: 3

max(fruits) - возвращает максимальный элемент в кортеже (лексикографически для строк)
    max(fruits) # результат: 'яблоко'

min(fruits) - возвращает минимальный элемент в кортеже (лексикографически для строк)
    min(fruits) # результат: 'банан'

tuple(iterable) - преобразует итерируемый объект в кортеж
    tuple(['груша', 'ананас']) # результат: ('груша', 'ананас')

# Операции с кортежами

# Конкатенация кортежей
fruits + ('апельсин',) # результат: ('яблоко', 'банан', 'вишня', 'апельсин')

# Повторение кортежа
fruits * 2 # результат: ('яблоко', 'банан', 'вишня', 'яблоко', 'банан', 'вишня')

# Проверка на наличие элемента
'яблоко' in fruits # результат: True

# Итерация по элементам кортежа
for fruit in fruits:
    print(fruit)
# Вывод:
# яблоко
# банан
# вишня
"""



# Словарь контактов
contacts = {
    'Алиса': '+123456789',
    'Боб': '+987654321',
    'Чарли': '+192837465'
}

"""
Тип данных - словарь

Смысл словаря - хранение информации под ключевыми названиями.
Контакты в телефоне: под именем хранится номер абонента
Продукты на кассе - под названием хранится цена продукта
ARP-таблица - под MAC-адресом хранится IP-адрес


contacts.clear() - удаляет все элементы из словаря
    contacts.clear() # результат: {}

contacts.copy() - возвращает поверхностную копию словаря
    contacts_copy = contacts.copy() # результат: {'Алиса': '+123456789', 'Боб': '+987654321', 'Чарли': '+192837465'}

contacts.get(key, default) - возвращает значение, связанное с ключом key. Если ключа нет, возвращает значение default (по умолчанию None)
    contacts.get('Алиса') # результат: '+123456789'
    contacts.get('Дэвид', 'Не найдено') # результат: 'Не найдено'

contacts.items() - возвращает объект-представление всех пар (ключ, значение) в словаре
    for name, number in contacts.items():
        print(name, number)
# Вывод:
# Алиса +123456789
# Боб +987654321
# Чарли +192837465

contacts.keys() - возвращает объект-представление всех ключей в словаре
    contacts.keys() # результат: dict_keys(['Алиса', 'Боб', 'Чарли'])

contacts.pop(key, default) - удаляет ключ и возвращает его значение. Если ключ не найден, возвращает default (по умолчанию вызывает ошибку)
    contacts.pop('Боб') # результат: '+987654321', словарь: {'Алиса': '+123456789', 'Чарли': '+192837465'}
    contacts.pop('Дэвид', 'Не найдено') # результат: 'Не найдено'

contacts.popitem() - удаляет и возвращает последнюю добавленную пару (ключ, значение) в виде кортежа. Если словарь пуст, вызывает ошибку
    contacts.popitem() # результат: ('Чарли', '+192837465'), словарь: {'Алиса': '+123456789', 'Боб': '+987654321'}

contacts.setdefault(key, default) - возвращает значение по ключу key. Если ключа нет, добавляет его со значением default и возвращает default
    contacts.setdefault('Элли', '+111222333') # результат: '+111222333', словарь: {'Алиса': '+123456789', 'Боб': '+987654321', 'Чарли': '+192837465', 'Элли': '+111222333'}

contacts.update(other) - обновляет словарь, добавляя пары ключ-значение из другого словаря other
    contacts.update({'Дэвид': '+555666777'}) # результат: {'Алиса': '+123456789', 'Боб': '+987654321', 'Чарли': '+192837465', 'Дэвид': '+555666777'}

contacts.values() - возвращает объект-представление всех значений в словаре
    contacts.values() # результат: dict_values(['+123456789', '+987654321', '+192837465'])
"""


# Множество городов
cities = {'Новосибирск', 'Екатеринбург', 'Казань'}

"""
Тип данных - множества (set)

Это изменяемый тип данных, который не содержат дубликатов и не имеют порядка.
Проще говоря, если вы играете в Города и сохраняете каждый город в множество, то даже дважды названный город будет в множестве только один раз.

cities.add(x) - добавляет элемент x в множество
    cities.add('Владивосток') # результат: {'Новосибирск', 'Екатеринбург', 'Казань', 'Владивосток'}

cities.clear() - удаляет все элементы из множества
    cities.clear() # результат: set()

cities.copy() - возвращает поверхностную копию множества
    cities_copy = cities.copy() # результат: {'Новосибирск', 'Екатеринбург', 'Казань'}

cities.discard(x) - удаляет элемент x из множества, если он присутствует
    cities.discard('Казань') # результат: {'Новосибирск', 'Екатеринбург'}

cities.remove(x) - удаляет элемент x из множества, вызывает ошибку, если элемент не найден
    cities.remove('Екатеринбург') # результат: {'Новосибирск', 'Казань'}

cities.pop() - удаляет и возвращает случайный элемент из множества, вызывает ошибку, если множество пусто
    random_city = cities.pop() # результат: 'Новосибирск' (например), множество: {'Екатеринбург', 'Казань'}

cities.update(other) - добавляет в множество все элементы из другого множества или итерируемого объекта other
    cities.update({'Сочи', 'Уфа'}) # результат: {'Новосибирск', 'Екатеринбург', 'Казань', 'Сочи', 'Уфа'}

cities.union(other) - возвращает объединение текущего множества и другого множества или итерируемого объекта other
    new_cities = cities.union({'Пермь', 'Самара'}) # результат: {'Новосибирск', 'Екатеринбург', 'Казань', 'Пермь', 'Самара'}

cities.intersection(other) - возвращает пересечение текущего множества и другого множества или итерируемого объекта other
    common_cities = cities.intersection({'Казань', 'Сочи'}) # результат: {'Казань'}

cities.difference(other) - возвращает разность текущего множества и другого множества или итерируемого объекта other
    diff_cities = cities.difference({'Казань', 'Владивосток'}) # результат: {'Новосибирск', 'Екатеринбург'}

cities.symmetric_difference(other) - возвращает симметрическую разность текущего множества и другого множества или итерируемого объекта other
    sym_diff_cities = cities.symmetric_difference({'Казань', 'Владивосток'}) # результат: {'Новосибирск', 'Екатеринбург', 'Владивосток'}

cities.isdisjoint(other) - возвращает True, если текущее множество и другое множество или итерируемый объект other не имеют общих элементов
    is_disjoint = cities.isdisjoint({'Москва', 'Санкт-Петербург'}) # результат: True

cities.issubset(other) - возвращает True, если текущее множество является подмножеством другого множества или итерируемого объекта other
    is_subset = {'Казань'}.issubset(cities) # результат: True

cities.issuperset(other) - возвращает True, если текущее множество является надмножеством другого множества или итерируемого объекта other
    is_superset = cities.issuperset({'Новосибирск', 'Екатеринбург'}) # результат: True
"""